(*link pros slides: https://drive.google.com/open?id=1QGEjtj41JJPet6rVrFoiDohjFCYRYAhd7RuK-l4HRhs*)

node ilumination ( c1, c2, c_up, c_down, up, down, ar_fail, shift : bool ) returns (  lamp, pers, policy : int )
	let
		automaton
			state Off do
				lamp = 0;
				pers = 0;
				policy = 0;
				unless not c1 or (up & c_up) then Min
					| not c2 then Max
					(* | ar_fail then Off_Up *)

			state Off_Up do
				lamp = 2;
				pers = 0;
				policy = 4;
				unless not ar_fail & shift then Off
					| not ar_fail & not shift then Max
		
			state Min do
				lamp = 1;
				pers = 1;
				policy = 1;
				unless not c1 or (down & c_down) then Off
					| not c2 or (up & c_up) then Max
					(* | ar_fail then Off_Up *)
		
			state Max do
				lamp = 2;
				pers = 2;
				policy = 2;
				unless not c1 or (down & c_down) then Min
					| not c2 then Off
					| ar_fail then Off_Up
					(* | ar_fail then Off_Up *)

			state Max_Up do
				lamp = 0;
				pers = 0;
				policy = 5;
				unless not ar_fail & shift then Off
					| not ar_fail & not shift then Off
		end
	tel

node lamp ( c1, c2, sw : bool ) returns ( lamp_on : int )
	let
		automaton
			state Off do
				lamp_on = 0;
				unless (c1 & sw) or not c2 then On

			state On do
				lamp_on = 1;
				unless (c1 & sw) or not c2 then Off
		end
	tel

node blind ( c1, c2, sw: bool ) returns ( blind_open : int )
	let
		automaton
			state Down do
				blind_open = 0;
				unless (c1 & sw) or not c2 then Up

			state Up do
				blind_open = 1;
				unless (c1 & sw) or not c2 then Down
		end
	tel

node door ( push, c1, c2 : bool ) returns ( door_open : bool )
	let
	    automaton
		    state Closed do
				door_open = false;
			    unless (push & c2) or not c1 then Open
		    state Open do
				door_open = true;
			    unless (push & c2) or not c1 then Closed
	    end
	tel


node closet ( c : bool ) returns ( closet_open : bool )
	let
		automaton
			state Locked do
				closet_open = false;
				unless not c then Open
			state Open do
				closet_open = true;
				unless c then Locked
		end
	tel

node person ( arrived : bool ) returns ( presence : bool )
	let
		automaton
			state Not_Present do
				presence = false;
				unless arrived then Present
			state Present do
				presence = true;
				unless arrived then Not_Present
		end
	tel

node computer ( c : bool ) returns ( computer_on : bool )
	let
		automaton
			state Off do
				computer_on = false;
				unless c then On
			state On do
				computer_on = true;
				unless not c then Off
		end
	tel

node window ( c : bool ) returns ( window_open : bool )
	let
		automaton
			state Closed do
				window_open = false;
				unless not c then Open
				
			state Open do
				window_open = true;
				unless c then Closed
				
		end
	tel

node air_conditioner ( c1, c2 : bool ) returns ( air_state : int )
	let
		automaton
			state Off do
				air_state = 0;
				unless c1 then Min
					| not c2 then Max
			state Min do
				air_state = 1;
				unless not c1 then Off
					| not c2 then Max
			state Max do
				air_state = 2;
				unless not c1 then Min
					| not c2 then Off
		end
	tel

node day_shift (change : bool) returns ( night : bool)
	let
		automaton
			state Dia do
				night = false
				unless change then Noite
			state Noite do
				night = true
				unless change then Dia
		end
	tel

node fail (failed_recovered: bool) returns (failed : bool)
	let
		automaton
			state Funcionando do
				failed = false
				unless failed_recovered then Falha
			state Falha do
				failed = true
				unless failed_recovered then Funcionando
		end
	tel

node air_fail (c1, c2, failed_recovered:bool) returns (out: int;)
	var air_state : int; failed : bool;
	let
		air_state = inlined air_conditioner (c1, c2);
		failed = inlined fail(failed_recovered);
		switch failed
		 | true do out = air_state + 3
		 | false do out = air_state
		end
	tel

node lamp_fail (sw, c1, c2, failed_recovered: bool) returns (out: int;)
	var lamp : int; failed: bool;
	let
		lamp = inlined lamp(sw, c1, c2);
		failed = inlined fail(failed_recovered);
		switch failed
		 | true do out = lamp + 2
		 | false do out = lamp
		end
	tel

node blind_fail (sw, c1, c2, failed_recovered: bool) returns (blind:int; failed: bool; out: int;)
	(* var lamp : int; failed: bool; *)
	let
		blind = inlined blind(sw, c1, c2);
		failed = inlined fail(failed_recovered);	
		switch failed
		 | true do out = blind + 3
		 | false do out = blind
		end
	tel

node controller( change_shift, (* push *) worker, cleaner, air_failed_recovered, light_switch, light_failed_recovered, blind_switch, blind_failed_recovered: bool)
	
	returns (night, door_open, worker_presence, cleaner_presence, pc_on, window_open, 
	closet_open, blind_up, blind_failed: bool; air_out, light_out : int;)
  	
  	contract
		var rule1, rule1_5, rule2, rule2_5, rule3, rule4, rule5, rule5_5, rule6, rule7, rule8, rule9  : bool;

		let
			rule1 = not ((worker_presence or cleaner_presence) & night & light_out < 2 & air_out < 3) or (light_out = 1 & air_out = 1);
		    rule1_5 = not ((worker_presence or cleaner_presence) & night & light_out < 2 & air_out > 2 ) or (window_open & blind_up & door_open);
		    rule2 = not ((worker_presence or cleaner_presence) & night & light_out > 1 & air_out < 3) or (blind_up & air_out = 1);
		    rule2_5 = not ((worker_presence or cleaner_presence) & night & light_out > 1 & air_out > 2) or (window_open & blind_up & door_open);

		    rule3 = not (not worker_presence & not cleaner_presence & night) or (not pc_on & not window_open & light_out <> 1 & not blind_up);
		    rule4 = not (not worker_presence & not cleaner_presence & not night) or (not pc_on & not window_open & light_out <> 1 & not blind_up);

		    rule5 = not (not night & pc_on & light_out = 1 & not window_open & air_out < 3) or air_out = 2;
		    rule5_5 = not (not night & pc_on & light_out <> 1 & not window_open & air_out < 3) or air_out = 1;
		    rule6 = not (cleaner_presence & air_out < 3) or ((not pc_on) & closet_open & air_out = 1);
		    
		    rule7 = not ((worker_presence or cleaner_presence) & not night & light_out < 2) or (light_out = 1);
		    rule8 = not ((worker_presence or cleaner_presence) & not night & air_out > 2) or ( window_open & blind_up & door_open);

		    rule9 = not ((worker_presence or cleaner_presence) & not night) or (light_out = 1 or blind_up)
		tel
    enforce (rule1 & rule1_5 & rule2 & rule2_5 & rule3 & rule4 & rule5 & rule5_5 & rule6 & rule7 & rule8 & rule9 )
    with ( c_door_1, c_door_2, c_pc, c_window, c_air_1, c_air_2, c_closet,  c_light_1, c_light_2, c_blind_1, c_blind_2 : bool )

  	let
  		night = inlined day_shift (change_shift);
		door_open = inlined door (false, c_door_1, c_door_2);
		closet_open = inlined closet (c_closet);
		worker_presence = inlined person (worker);
		cleaner_presence = inlined person (cleaner);
		pc_on = inlined computer (c_pc);
		window_open = inlined window (c_window);
		air_out = inlined air_fail (c_air_1, c_air_2, air_failed_recovered);
  		light_out = inlined lamp_fail(light_switch, c_light_1, c_light_2, light_failed_recovered);
  		(blind_up, blind_failed) = inlined blind_fail(blind_switch, c_blind_1, c_blind_2, blind_failed_recovered);
	tel
